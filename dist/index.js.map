{"version":3,"file":"index.js","mappings":"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","sources":["webpack://auth/./node_modules/@tsndr/cloudflare-worker-jwt/index.js","webpack://auth/./src/wallet.js","webpack://auth/webpack/bootstrap","webpack://auth/./src/index.js"],"sourcesContent":["class Base64URL {\n    static parse(s) {\n        return new Uint8Array(Array.prototype.map.call(atob(s.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '')), c => c.charCodeAt(0)))\n    }\n    static stringify(a) {\n        return btoa(String.fromCharCode.apply(0, a)).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_')\n    }\n}\n\nclass JWT {\n    constructor() {\n        if (!crypto || !crypto.subtle)\n            throw new Error('Crypto not supported!')\n        this.algorithms = {\n            ES256: { name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },\n            ES384: { name: 'ECDSA', namedCurve: 'P-384', hash: { name: 'SHA-384' } },\n            ES512: { name: 'ECDSA', namedCurve: 'P-512', hash: { name: 'SHA-512' } },\n            HS256: { name: 'HMAC', hash: { name: 'SHA-256' } },\n            HS384: { name: 'HMAC', hash: { name: 'SHA-384' } },\n            HS512: { name: 'HMAC', hash: { name: 'SHA-512' } }\n        }\n    }\n    _utf8ToUint8Array(str) {\n        return Base64URL.parse(btoa(unescape(encodeURIComponent(str))))\n    }\n    _str2ab(str) {\n        const buf = new ArrayBuffer(str.length);\n        const bufView = new Uint8Array(buf);\n        for (let i = 0, strLen = str.length; i < strLen; i++) {\n            bufView[i] = str.charCodeAt(i);\n        }\n        return buf;\n    }\n    _decodePayload(raw) {\n        switch (raw.length % 4) {\n            case 0:\n                break\n            case 2:\n                raw += '=='\n                break\n            case 3:\n                raw += '='\n                break\n            default:\n                throw new Error('Illegal base64url string!')\n        }\n        try {\n            return JSON.parse(decodeURIComponent(escape(atob(raw))))\n        } catch {\n            return null\n        }\n    }\n    async sign(payload, secret, options = { algorithm: 'HS256' }) {\n        if (typeof options === 'string')\n            options = { algorithm: options }\n        if (payload === null || typeof payload !== 'object')\n            throw new Error('payload must be an object')\n        if (typeof secret !== 'string')\n            throw new Error('secret must be a string')\n        if (typeof options.algorithm !== 'string')\n            throw new Error('options.algorithm must be a string')\n        const importAlgorithm = this.algorithms[options.algorithm]\n        if (!importAlgorithm)\n            throw new Error('algorithm not found')\n        payload.iat = Math.floor(Date.now() / 1000)\n        const payloadAsJSON = JSON.stringify(payload)\n        const partialToken = `${Base64URL.stringify(this._utf8ToUint8Array(JSON.stringify({ alg: options.algorithm, kid: options.keyid })))}.${Base64URL.stringify(this._utf8ToUint8Array(payloadAsJSON))}`\n        let keyFormat = 'raw'\n        let keyData\n        if (secret.startsWith('-----BEGIN')) {\n            keyFormat = 'pkcs8'\n            keyData = this._str2ab(atob(secret.replace(/-----BEGIN.*?-----/g, '').replace(/-----END.*?-----/g, '').replace(/\\s/g, '')))\n        } else\n            keyData = this._utf8ToUint8Array(secret)\n        const key = await crypto.subtle.importKey(keyFormat, keyData, importAlgorithm, false, ['sign'])\n        const signature = await crypto.subtle.sign(importAlgorithm, key, this._utf8ToUint8Array(partialToken))\n        return `${partialToken}.${Base64URL.stringify(new Uint8Array(signature))}`\n    }\n    async verify(token, secret, options = { algorithm: 'HS256' }) {\n        if (typeof options === 'string')\n            options = { algorithm: options }\n        if (typeof token !== 'string')\n            throw new Error('token must be a string')\n        if (typeof secret !== 'string')\n            throw new Error('secret must be a string')\n        if (typeof options.algorithm !== 'string')\n            throw new Error('options.algorithm must be a string')\n        const tokenParts = token.split('.')\n        if (tokenParts.length !== 3)\n            throw new Error('token must consist of 3 parts')\n        const importAlgorithm = this.algorithms[options.algorithm]\n        if (!importAlgorithm)\n            throw new Error('algorithm not found')\n        const payload = this.decode(token)\n        if (payload.nbf && payload.nbf >= Math.floor(Date.now() / 1000))\n            return false\n        if (payload.exp && payload.exp < Math.floor(Date.now() / 1000))\n            return false\n        let keyFormat = 'raw'\n        let keyData\n        if (secret.startsWith('-----BEGIN')) {\n            keyFormat = 'pkcs8'\n            keyData = this._str2ab(atob(secret.replace(/-----BEGIN.*?-----/g, '').replace(/-----END.*?-----/g, '').replace(/\\s/g, '')))\n        } else\n            keyData = this._utf8ToUint8Array(secret)\n        const key = await crypto.subtle.importKey(keyFormat, keyData, importAlgorithm, false, ['sign'])\n        const res = await crypto.subtle.sign(importAlgorithm, key, this._utf8ToUint8Array(tokenParts.slice(0, 2).join('.')))\n        return Base64URL.stringify(new Uint8Array(res)) === tokenParts[2]\n    }\n    decode(token) {\n        return this._decodePayload(token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/'))\n    }\n}\n\nmodule.exports = new JWT\n","module.exports = class Wallet {\n    constructor(state, env) {\n      this.state = state;\n      this.env = env\n    }\n  \n    async getWalletSessionSecret(){\n      await this.state.storage.get('sessionSecret')\n      return true\n  \n    }\n  \n    async setWalletSessionSecret(uuid){\n      await this.state.storage.put('sessionSecret', uuid);\n      return true\n  \n    }\n  \n    async fetch(request) {\n      let key = new URL(request.url).host;\n      let ifMatch = request.headers.get('If-Match');\n      let newValue = await request.text();\n      let changedValue = false;\n      await this.state.storage.transaction(async txn => {\n        let currentValue = await txn.get(key);\n        if (currentValue != ifMatch && ifMatch != '*') {\n          txn.rollback();\n          return;\n        }\n        changedValue = true;\n        await txn.put(key, newValue);\n      });\n      return new Response('Changed: ' + changedValue);\n    }\n  }","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nconst Wallet = require('./wallet')\n\n\n// const { recoverPersonalSignature } = require(\"@metamask/eth-sig-util\");\nconst jwt = require('@tsndr/cloudflare-worker-jwt')\n\n\nconst BACKEND_WEBSOCKET_URL = 'https://socket.dauth.dev/'\n\nexports.Wallet = Wallet\nexports.handlers = {\n  \n  async fetch(request, env) {\n\n    const url = new URL(request.url);\n    const uri = url.pathname;\n    if (uri.includes(\"/walletAuth\") && request.method === 'POST') {\n      return await handleWalletAuth(request, env)\n\n    }else if (uri.includes(\"/auth\") && request.method === 'POST'){\n      return await handleUserAuth(request, env)\n\n    }else{\n      const headers = {\n        \"content-type\": \"application/json\",\n        \"Access-Control-Allow-Origin\":\"*\",\n        \"Access-Control-Allow-Headers\": \"Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, Control-Allow-Origin\"\n      }\n      return new Response(JSON.stringify({'message':\"Hello :)\"}),{headers:headers})\n  \n    }\n  },\n}\n\n\nasync function handleWalletAuth(request, env){\n  var body, OTK, fromWallet, rawMessage, signedMessage;\n  const headers = {\n    \"content-type\": \"application/json\",\n    \"Access-Control-Allow-Origin\":\"*\",\n    \"Access-Control-Allow-Headers\": \"Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, Control-Allow-Origin\"\n  }\n  try{\n    body = JSON.parse(await request.text())\n  }catch{\n    return new Response(JSON.stringify({'errorCode': 1001, 'errorMessage':'body was not valid JSON'}),{headers:headers})\n  }\n\n  try{\n    OTK = body.OTK\n  }catch{\n    return new Response(JSON.stringify({'errorCode': 1002, 'errorMessage':'OTK (One Time Key) was not provided in the message body.'}),{headers:headers})\n  }\n\n  try{\n    fromWallet = body.fromWallet\n  }catch{\n    return new Response(JSON.stringify({'errorCode': 1003, 'errorMessage':'fromWallet (The wallet which signed the message) was not provided in the message body.'}),{headers:headers})\n  }  \n  \n  try{\n    rawMessage = body.rawMessage\n  }catch{\n    return new Response(JSON.stringify({'errorCode': 1004, 'rawMessage':'rawMessage (the raw message) was not provided in the message body.'}),{headers:headers})\n  }\n\n  try{\n    signedMessage = body.signedMessage\n  }catch{\n    return new Response(JSON.stringify({'errorCode': 1005, 'errorMessage':'signedMessage (signed message) was not provided in the message body.'}),{headers:headers})\n  }\n\n  var signResult = {\n    logInSuccess: false,\n    logInMessage: 'Login failed.'\n  }\n  try {\n    // const fromWallet = fromWallet;\n    // const fromWallet = '0xb6ce25574f2862150f0a877ec48d138b7ee641ce'\n    const msg = `0x${Buffer.from(rawMessage, 'utf8').toString('hex')}`;\n    // const sign = personalSignResult.innerHTML;\n    // const sign = '0xab2de42d6c794289e8033404db699eb6f957b3ef078cf3c7681cccbcb87e0fce14301750935c3094c1feb1b05a402e569ba6e5dc0a9a1d9a8f866c902ca80e941b'\n    console.log(\"msg\")\n    console.log(msg)\n    console.log(signedMessage)\n    // const recoveredAddr = recoverPersonalSignature({\n    //   data: msg,\n    //   signature: signedMessage,\n    // });\n\n    if (recoveredAddr === fromWallet) {\n      console.log(`SigUtil Successfully verified signer as ${recoveredAddr}`);\n      signResult.logInSuccess = true\n      signResult.logInMessage = `SigUtil Successfully verified signer as ${recoveredAddr}`\n      // personalSignVerifySigUtilResult.innerHTML = recoveredAddr;\n    } else {\n      console.log(\n        `SigUtil Failed to verify signer when comparing ${recoveredAddr} to ${from}`,\n      );\n      console.log(`Failed comparing ${recoveredAddr} to ${from}`);\n      signResult.logInSuccess = false\n      signResult.logInMessage = `SigUtil Failed to verify signer when comparing ${recoveredAddr} to ${from}`\n    }\n\n  } catch (err) {\n    console.error(err);\n    new Response(JSON.stringify({'authResult':signResult}),{headers:headers})\n  }\n\n  const jwtToken = await getUserJWT()\n  const url = `${BACKEND_WEBSOCKET_URL}/push/${OTK}`\n  const init = {\n    method: \"POST\",\n    headers: {\n        \"content-type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n        \"Access-Control-Max-Age\": \"86400\",\n        \"Access-Control-Allow-Headers\": \"Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, sessionID, serverID, msgID\",\n        \"x-auth-token\": X_AUTH_TOKEN\n    },\n    body: signResult\n}\n\n\n\n  const response = await fetch(url, init);\n  console.log(response)\n  return new Response(JSON.stringify({'authResult':signResult}),{headers:headers})\n}\n\n\n\n\n\n\nasync function getUserJWT(fromWallet, nft){\n\n  // Creating a token\n  const tokenToSign = {\n    wallet: fromWallet,\n    nft: nft,\n  }\n\n  const sessionSecret = 'USER_SESSION_SECRET'\n  const secret = \"SECRET\" + sessionSecret\n  const token = await jwt.sign(tokenToSign, secret)\n\n  // Verifying token\n  const isValid = await jwt.verify(token, secret)\n\n  // Check for validity\n  if (!isValid)\n      return false\n\n  // Decoding token\n  const payload = jwt.decode(token)\n}\n\n\n/* A good implementation would query a database, look up the wallet and would store a unique string for example.\n   It doesnt have to be a string but should be something unique. For this example we will use UUIDs, a totally unique string. \n   \n   This UUID should be replaced with a new UUID whenever the user logs out.\n   \n   This way we can use the wallet address (from the payload of the JWT token) to get the UUID which will be used as apart of the secret.\n\n   Using this technique we can use a normal static SECRET and the UUID of the user, making it possible to log a user out by changing the\n   UUID in the database. + Its more secure.\n\n   Disclaimer: Because I am implementing a demonstration and I am not rich, I will be using a 'not so good' approach.\n   I will be using the Cloudflare Cache() method to simply cache wallets, the UUID of the wallet. \n*/\n\nasync function getUserAuthStore(walletAddress){\n\n  const wallet = await WALLET.get(walletAddress, {type: \"json\"})\n  return wallet.uuid\n}\n\nasync function setUserAuthStore(walletAddress, newUUID){\n\n  const walletData = {\n    uuid: newUUID\n  }\n\n  const wallet = await WALLET.put(walletAddress, JSON.stringify(walletData))\n  return wallet\n}\n\n"],"names":["Base64URL","static","s","Uint8Array","Array","prototype","map","call","atob","replace","c","charCodeAt","a","btoa","String","fromCharCode","apply","module","exports","constructor","crypto","subtle","Error","this","algorithms","ES256","name","namedCurve","hash","ES384","ES512","HS256","HS384","HS512","_utf8ToUint8Array","str","parse","unescape","encodeURIComponent","_str2ab","buf","ArrayBuffer","length","bufView","i","strLen","_decodePayload","raw","JSON","decodeURIComponent","escape","async","payload","secret","options","algorithm","importAlgorithm","iat","Math","floor","Date","now","payloadAsJSON","stringify","partialToken","alg","kid","keyid","keyData","keyFormat","startsWith","key","importKey","signature","sign","token","tokenParts","split","decode","nbf","exp","res","slice","join","state","env","storage","get","uuid","put","request","URL","url","host","ifMatch","headers","newValue","text","changedValue","transaction","txn","rollback","Response","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","Wallet","jwt","handlers","uri","pathname","includes","method","body","OTK","fromWallet","rawMessage","signedMessage","signResult","logInSuccess","logInMessage","msg","Buffer","from","toString","console","log","recoveredAddr","err","error","nft","tokenToSign","wallet","getUserJWT","verify","init","X_AUTH_TOKEN","response","fetch","handleWalletAuth","handleUserAuth"],"sourceRoot":""}