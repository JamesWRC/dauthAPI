/*! For license information please see index.js.LICENSE.txt */
(()=>{var e={"./node_modules/@tsndr/cloudflare-worker-jwt/index.js":e=>{class t{static parse(e){return new Uint8Array(Array.prototype.map.call(atob(e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"")),(e=>e.charCodeAt(0))))}static stringify(e){return btoa(String.fromCharCode.apply(0,e)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}}e.exports=new class{constructor(){if(!crypto||!crypto.subtle)throw new Error("Crypto not supported!");this.algorithms={ES256:{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}},ES384:{name:"ECDSA",namedCurve:"P-384",hash:{name:"SHA-384"}},ES512:{name:"ECDSA",namedCurve:"P-512",hash:{name:"SHA-512"}},HS256:{name:"HMAC",hash:{name:"SHA-256"}},HS384:{name:"HMAC",hash:{name:"SHA-384"}},HS512:{name:"HMAC",hash:{name:"SHA-512"}}}}_utf8ToUint8Array(e){return t.parse(btoa(unescape(encodeURIComponent(e))))}_str2ab(e){const t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0,s=e.length;t<s;t++)r[t]=e.charCodeAt(t);return t}_decodePayload(e){switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("Illegal base64url string!")}try{return JSON.parse(decodeURIComponent(escape(atob(e))))}catch{return null}}async sign(e,r,s={algorithm:"HS256"}){if("string"==typeof s&&(s={algorithm:s}),null===e||"object"!=typeof e)throw new Error("payload must be an object");if("string"!=typeof r)throw new Error("secret must be a string");if("string"!=typeof s.algorithm)throw new Error("options.algorithm must be a string");const o=this.algorithms[s.algorithm];if(!o)throw new Error("algorithm not found");e.iat=Math.floor(Date.now()/1e3);const n=JSON.stringify(e),a=`${t.stringify(this._utf8ToUint8Array(JSON.stringify({alg:s.algorithm,kid:s.keyid})))}.${t.stringify(this._utf8ToUint8Array(n))}`;let i,l="raw";r.startsWith("-----BEGIN")?(l="pkcs8",i=this._str2ab(atob(r.replace(/-----BEGIN.*?-----/g,"").replace(/-----END.*?-----/g,"").replace(/\s/g,"")))):i=this._utf8ToUint8Array(r);const c=await crypto.subtle.importKey(l,i,o,!1,["sign"]),g=await crypto.subtle.sign(o,c,this._utf8ToUint8Array(a));return`${a}.${t.stringify(new Uint8Array(g))}`}async verify(e,r,s={algorithm:"HS256"}){if("string"==typeof s&&(s={algorithm:s}),"string"!=typeof e)throw new Error("token must be a string");if("string"!=typeof r)throw new Error("secret must be a string");if("string"!=typeof s.algorithm)throw new Error("options.algorithm must be a string");const o=e.split(".");if(3!==o.length)throw new Error("token must consist of 3 parts");const n=this.algorithms[s.algorithm];if(!n)throw new Error("algorithm not found");const a=this.decode(e);if(a.nbf&&a.nbf>=Math.floor(Date.now()/1e3))return!1;if(a.exp&&a.exp<Math.floor(Date.now()/1e3))return!1;let i,l="raw";r.startsWith("-----BEGIN")?(l="pkcs8",i=this._str2ab(atob(r.replace(/-----BEGIN.*?-----/g,"").replace(/-----END.*?-----/g,"").replace(/\s/g,"")))):i=this._utf8ToUint8Array(r);const c=await crypto.subtle.importKey(l,i,n,!1,["sign"]),g=await crypto.subtle.sign(n,c,this._utf8ToUint8Array(o.slice(0,2).join(".")));return t.stringify(new Uint8Array(g))===o[2]}decode(e){return this._decodePayload(e.split(".")[1].replace(/-/g,"+").replace(/_/g,"/"))}}},"./src/wallet.js":e=>{e.exports=class{constructor(e,t){this.state=e,this.env=t}async getWalletSessionSecret(){return await this.state.storage.get("sessionSecret"),!0}async setWalletSessionSecret(e){return await this.state.storage.put("sessionSecret",e),!0}async fetch(e){let t=new URL(e.url).host,r=e.headers.get("If-Match"),s=await e.text(),o=!1;return await this.state.storage.transaction((async e=>{await e.get(t)==r||"*"==r?(o=!0,await e.put(t,s)):e.rollback()})),new Response("Changed: "+o)}}}},t={};function r(s){var o=t[s];if(void 0!==o)return o.exports;var n=t[s]={exports:{}};return e[s](n,n.exports,r),n.exports}var s={};(()=>{var e=s;const t=r("./src/wallet.js"),o=r("./node_modules/@tsndr/cloudflare-worker-jwt/index.js");e.Wallet=t,e.handlers={async fetch(e,t){const r=new URL(e.url).pathname;if(r.includes("/walletAuth")&&"POST"===e.method)return await async function(e,t){var r,s,n,a,i;const l={"content-type":"application/json","Access-Control-Allow-Origin":"*","Access-Control-Allow-Headers":"Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, Control-Allow-Origin"};try{r=JSON.parse(await e.text())}catch{return new Response(JSON.stringify({errorCode:1001,errorMessage:"body was not valid JSON"}),{headers:l})}try{s=r.OTK}catch{return new Response(JSON.stringify({errorCode:1002,errorMessage:"OTK (One Time Key) was not provided in the message body."}),{headers:l})}try{n=r.fromWallet}catch{return new Response(JSON.stringify({errorCode:1003,errorMessage:"fromWallet (The wallet which signed the message) was not provided in the message body."}),{headers:l})}try{a=r.rawMessage}catch{return new Response(JSON.stringify({errorCode:1004,rawMessage:"rawMessage (the raw message) was not provided in the message body."}),{headers:l})}try{i=r.signedMessage}catch{return new Response(JSON.stringify({errorCode:1005,errorMessage:"signedMessage (signed message) was not provided in the message body."}),{headers:l})}var c={logInSuccess:!1,logInMessage:"Login failed."};try{const e=`0x${Buffer.from(a,"utf8").toString("hex")}`;console.log("msg"),console.log(e),console.log(i),recoveredAddr===n?(console.log(`SigUtil Successfully verified signer as ${recoveredAddr}`),c.logInSuccess=!0,c.logInMessage=`SigUtil Successfully verified signer as ${recoveredAddr}`):(console.log(`SigUtil Failed to verify signer when comparing ${recoveredAddr} to ${from}`),console.log(`Failed comparing ${recoveredAddr} to ${from}`),c.logInSuccess=!1,c.logInMessage=`SigUtil Failed to verify signer when comparing ${recoveredAddr} to ${from}`)}catch(e){console.error(e),new Response(JSON.stringify({authResult:c}),{headers:l})}await async function(e,t){const r={wallet:void 0,nft:void 0},s="SECRETUSER_SESSION_SECRET",n=await o.sign(r,s);if(!await o.verify(n,s))return!1;o.decode(n)}();const g=`https://socket.dauth.dev//push/${s}`,d={method:"POST",headers:{"content-type":"application/json","Access-Control-Allow-Origin":"*","Access-Control-Allow-Methods":"GET,HEAD,POST,OPTIONS","Access-Control-Max-Age":"86400","Access-Control-Allow-Headers":"Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, sessionID, serverID, msgID","x-auth-token":X_AUTH_TOKEN},body:c},h=await fetch(g,d);return console.log(h),new Response(JSON.stringify({authResult:c}),{headers:l})}(e);if(r.includes("/auth")&&"POST"===e.method)return await handleUserAuth(e,t);{const e={"content-type":"application/json","Access-Control-Allow-Origin":"*","Access-Control-Allow-Headers":"Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, Control-Allow-Origin"};return new Response(JSON.stringify({message:"Hello :)"}),{headers:e})}}}})();var o=exports;for(var n in s)o[n]=s[n];s.__esModule&&Object.defineProperty(o,"__esModule",{value:!0})})();
//# sourceMappingURL=index.js.map